package task

import (
	"encoding/json"
	"fmt"
	"time"

	"chrome-agent/internal/llm"
	"chrome-agent/internal/mcp"
	"chrome-agent/pkg/logger"
)

// Executor executes subtasks using LLM and MCP
type Executor struct {
	mcpClient *mcp.Client
	llmCoord  *llm.Coordinator
	logger    *logger.Logger
}

// ExecutionResult contains execution result
type ExecutionResult struct {
	Success   bool
	Result    interface{}
	Error     error
	Duration  time.Duration
	ToolCalls []llm.ToolCall
}

// NewExecutor creates a new task executor
func NewExecutor(mcpClient *mcp.Client, llmCoord *llm.Coordinator, log *logger.Logger) *Executor {
	return &Executor{
		mcpClient: mcpClient,
		llmCoord:  llmCoord,
		logger:    log,
	}
}

// ExecuteSubtask executes a subtask
func (e *Executor) ExecuteSubtask(subtaskName string, subtaskDescription string, context string) (*ExecutionResult, error) {
	startTime := time.Now()
	result := &ExecutionResult{
		ToolCalls: make([]llm.ToolCall, 0),
	}

	e.logger.Info("Executing subtask: %s", subtaskName)
	e.logger.Debug("Subtask description: %s", subtaskDescription)

	// Get available tools from MCP
	tools, err := e.mcpClient.ListTools()
	if err != nil {
		return nil, fmt.Errorf("failed to list tools: %w", err)
	}

	// Convert tools to interface slice for LLM
	toolsInterface := make([]interface{}, len(tools))
	for i, tool := range tools {
		toolMap := map[string]interface{}{
			"name":        tool.Name,
			"description": tool.Description,
			"inputSchema": tool.InputSchema,
		}
		toolsInterface[i] = toolMap
	}

	// Use LLM to reason about the subtask
	reasoning, err := e.llmCoord.ReasonAboutSubtask(subtaskDescription, context, toolsInterface)
	if err != nil {
		result.Error = fmt.Errorf("LLM reasoning failed: %w", err)
		result.Success = false
		result.Duration = time.Since(startTime)
		return result, result.Error
	}

	e.logger.Debug("LLM reasoning: %s", reasoning.Reasoning)
	if len(reasoning.ToolCalls) == 0 {
		e.logger.Warn("No tool calls generated by LLM")
		result.Success = true
		result.Result = "No actions required"
		result.Duration = time.Since(startTime)
		return result, nil
	}

	// Execute tool calls
	results := make([]interface{}, 0)
	for _, toolCall := range reasoning.ToolCalls {
		e.logger.Info("Calling tool: %s", toolCall.Name)
		e.logger.Debug("Tool arguments: %v", toolCall.Arguments)

		toolResult, err := e.mcpClient.CallTool(toolCall.Name, toolCall.Arguments)
		if err != nil {
			e.logger.Error("Tool call failed: %v", err)
			result.ToolCalls = append(result.ToolCalls, toolCall)
			result.Error = fmt.Errorf("tool %s failed: %w", toolCall.Name, err)
			result.Success = false
			result.Duration = time.Since(startTime)
			return result, result.Error
		}

		var parsedResult interface{}
		if err := json.Unmarshal(toolResult, &parsedResult); err != nil {
			parsedResult = string(toolResult)
		}

		results = append(results, map[string]interface{}{
			"tool":   toolCall.Name,
			"result": parsedResult,
		})

		result.ToolCalls = append(result.ToolCalls, toolCall)
		e.logger.Info("Tool %s completed successfully", toolCall.Name)
	}

	result.Success = true
	result.Result = results
	result.Duration = time.Since(startTime)
	e.logger.Info("Subtask completed in %v", result.Duration)

	return result, nil
}

// ExecuteSubtaskRule executes a subtask rule
func (e *Executor) ExecuteSubtaskRule(rule SubtaskRule, context string) (*ExecutionResult, error) {
	// Combine rule description and steps
	description := rule.Description
	if len(rule.Steps) > 0 {
		description += "\nSteps:\n"
		for i, step := range rule.Steps {
			description += fmt.Sprintf("%d. %s\n", i+1, step)
		}
	}

	return e.ExecuteSubtask(rule.Name, description, context)
}

